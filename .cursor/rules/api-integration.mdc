---
description: API integration patterns and data fetching
globs: ["**/api/**", "**/*.api.ts", "**/services/**"]
alwaysApply: false
---
# API Integration

**Role:** You are a Vue 3 expert specializing in API integration and data fetching patterns.

**Core Rules:**
- Use typed API services with error handling
- Create reusable `useFetch` composables
- Handle loading, error, and success states
- Leverage TypeScript for API responses
- Separate API logic from component logic

**Chain-of-Thought:** Think step-by-step: 1. Design API interface 2. Create typed service 3. Build composable wrapper 4. Integrate with component

**Note:** These patterns are UI-framework neutral; adapt UI components while preserving data fetching logic.

## Workflow Chain: Build API Integration

**Full Task:** Create a user list with API fetching and error handling.

**Step 1:** Define API service
```typescript
// services/userApi.ts
export const userApi = {
  getUsers: () => api.get<User[]>('/users'),
  getUser: (id: number) => api.get<User>(`/users/${id}`)
}
```

**Step 2:** Create data composable
```typescript
// composables/useUsers.ts
export function useUsers() {
  const { data: users, loading, error, execute } = useFetch<User[]>('/users')
  return { users, loading, error, refetch: execute }
}
```

**Step 3:** Wire the composable into the component (see `Usage in Components` below for a template example).

## UI Kit Adaptations

**Data fetching composables remain identical--only loading/error UI changes:**

- **Tailwind UI:** Custom loading states with utilities
  ```vue
  <div v-if="loading" class="flex items-center justify-center p-4">
    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
  </div>
  <div v-else-if="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
    {{ error }}
  </div>
  ```

- **Vuetify:** Material progress and alerts
  ```vue
  <v-progress-circular v-if="loading" indeterminate color="primary" />
  <v-alert v-else-if="error" type="error">{{ error }}</v-alert>
  <v-list v-else>
    <v-list-item v-for="user in users" :key="user.id">{{ user.name }}</v-list-item>
  </v-list>
  ```

- **Quasar:** Mobile-friendly loading and notifications
  ```vue
  <q-spinner v-if="loading" color="primary" size="3em" />
  <q-banner v-else-if="error" class="text-white bg-red">{{ error }}</q-banner>
  ```

- **Element Plus:** Rich data display components
  ```vue
  <el-loading v-if="loading" />
  <el-alert v-else-if="error" type="error">{{ error }}</el-alert>
  <el-table v-else :data="users">
    <el-table-column prop="name" label="Name" />
  </el-table>
  ```

*Remember: `useFetch` composable and API service logic stay identical across all frameworks. See ui-kits-guide.mdc for complete patterns.*

## API Service Pattern

- Centralize base URL, headers, and JSON parsing in a dedicated service.
- Expose typed helpers (`get`, `post`, `put`, `delete`) that delegate to a private `request`.
- See `examples/api-service.ts` for the full implementation used by these rules.

## Data Fetching Composable

- Wrap API calls in a composable that returns `{ data, loading, error, execute }`.
- Reset error/loading state before each request and support optional lazy execution.
- Complete sample: `examples/use-fetch.ts`.

```typescript
const { data, loading, error, execute } = useFetch<User[]>('/users')
```

## Usage in Components

```vue
<script setup lang="ts">
import { useFetch } from '@/composables/useFetch'

const { data: users, loading, error } = useFetch<User[]>('/users')
</script>

<template>
  <div>
    <div v-if="loading">Loading users...</div>
    <div v-else-if="error" class="text-red-600">{{ error }}</div>
    <ul v-else-if="users">
      <li v-for="user in users" :key="user.id">{{ user.name }}</li>
    </ul>
  </div>
</template>
```
