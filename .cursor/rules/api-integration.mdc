---
description: API integration patterns and data fetching
globs: ["**/api/**", "**/*.api.ts", "**/services/**"]
alwaysApply: false
---
# API Integration

**Role:** You are a Vue 3 expert specializing in API integration and data fetching patterns.

**Core Rules:**
- Use typed API services with error handling
- Create reusable `useFetch` composables
- Handle loading, error, and success states
- Leverage TypeScript for API responses
- Separate API logic from component logic

**Chain-of-Thought:** Think step-by-step: 1. Design API interface 2. Create typed service 3. Build composable wrapper 4. Integrate with component

**Note:** These patterns are UI-framework neutral; adapt UI components while preserving data fetching logic.

## Workflow Chain: Build API Integration

**Full Task:** Create a user list with API fetching and error handling.

**Step 1:** Define API service
```typescript
// services/userApi.ts
export const userApi = {
  getUsers: () => api.get<User[]>('/users'),
  getUser: (id: number) => api.get<User>(`/users/${id}`)
}
```

**Step 2:** Create data composable
```typescript
// composables/useUsers.ts
export function useUsers() {
  const { data: users, loading, error, execute } = useFetch<User[]>('/users')
  return { users, loading, error, refetch: execute }
}
```

**Step 3:** Complete component integration (see composables.mdc for patterns):
```vue
<script setup lang="ts">
import { useUsers } from '@/composables/useUsers'

const { users, loading, error, refetch } = useUsers()
</script>

<template>
  <div>
    <button @click="refetch" :disabled="loading">Refresh</button>
    <div v-if="loading">Loading...</div>
    <div v-else-if="error" class="text-red-600">{{ error }}</div>
    <ul v-else class="space-y-2">
      <li v-for="user in users" :key="user.id">{{ user.name }}</li>
    </ul>
  </div>
</template>
```

## UI Kit Adaptations

**Data fetching composables remain identicalâ€”only loading/error UI changes:**

- **Tailwind UI:** Custom loading states with utilities
  ```vue
  <div v-if="loading" class="flex items-center justify-center p-4">
    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
  </div>
  <div v-else-if="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
    {{ error }}
  </div>
  ```

- **Vuetify:** Material progress and alerts
  ```vue
  <v-progress-circular v-if="loading" indeterminate color="primary" />
  <v-alert v-else-if="error" type="error">{{ error }}</v-alert>
  <v-list v-else>
    <v-list-item v-for="user in users" :key="user.id">{{ user.name }}</v-list-item>
  </v-list>
  ```

- **Quasar:** Mobile-friendly loading and notifications
  ```vue
  <q-spinner v-if="loading" color="primary" size="3em" />
  <q-banner v-else-if="error" class="text-white bg-red">{{ error }}</q-banner>
  ```

- **Element Plus:** Rich data display components
  ```vue
  <el-loading v-if="loading" />
  <el-alert v-else-if="error" type="error">{{ error }}</el-alert>
  <el-table v-else :data="users">
    <el-table-column prop="name" label="Name" />
  </el-table>
  ```

*Remember: `useFetch` composable and API service logic stay identical across all frameworks. See ui-kits-guide.mdc for complete patterns.*

## API Service Pattern

```typescript
// services/api.ts
const API_BASE = import.meta.env.VITE_API_URL

class ApiService {
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${API_BASE}${endpoint}`
    
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    })
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`)
    }
    
    return response.json()
  }
  
  get<T>(endpoint: string) {
    return this.request<T>(endpoint)
  }
  
  post<T>(endpoint: string, data: unknown) {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    })
  }
  
  put<T>(endpoint: string, data: unknown) {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    })
  }
  
  delete<T>(endpoint: string) {
    return this.request<T>(endpoint, {
      method: 'DELETE',
    })
  }
}

export const api = new ApiService()
```

## Data Fetching Composable

```typescript
// composables/useFetch.ts
import { ref, onMounted } from 'vue'

export function useFetch<T>(url: string, immediate = true) {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const execute = async () => {
    try {
      loading.value = true
      error.value = null
      data.value = await api.get<T>(url)
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }
  
  if (immediate) {
    onMounted(execute)
  }
  
  return { data, loading, error, execute }
}
```

## Usage in Components

```vue
<script setup lang="ts">
import { useFetch } from '@/composables/useFetch'

interface User {
  id: number
  name: string
  email: string
}

const { data: users, loading, error } = useFetch<User[]>('/users')
</script>

<template>
  <div>
    <div v-if="loading">Loading users...</div>
    <div v-else-if="error">Error: {{ error }}</div>
    <ul v-else-if="users">
      <li v-for="user in users" :key="user.id">
        {{ user.name }} - {{ user.email }}
      </li>
    </ul>
  </div>
</template>
```