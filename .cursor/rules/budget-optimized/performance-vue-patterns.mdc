---
title: Performance-First Vue Patterns
tags: [vue3, performance, memory]
globs: ["src/**/*.vue", "src/**/*.ts"]
---

# Performance-First Vue Patterns

## Reactive Performance
- Use `shallowRef` for large arrays/objects that don't need deep reactivity
- Prefer `computed` over `watch` for derived values
- Use `readonly` for props passed to child components
- Implement `v-memo` for expensive list renders

## Memory Management
```typescript
// ✅ Efficient large data handling
const bigDataSet = shallowRef<LargeObject[]>([])
const filteredData = computed(() => 
  bigDataSet.value.filter(item => item.status === selectedStatus.value)
)

// ✅ Cleanup in onBeforeUnmount
onBeforeUnmount(() => {
  // Clear intervals, remove event listeners
  clearInterval(intervalId)
  window.removeEventListener('resize', handleResize)
})
```

## Lazy Loading Patterns
```typescript
// ✅ Lazy load heavy components
const HeavyChart = defineAsyncComponent(() => import('@/components/HeavyChart.vue'))

// ✅ Lazy load composables
const useExpensiveFeature = () => import('@/composables/useExpensiveFeature')
```

## Template Optimization
```vue
<!-- ✅ Use v-memo for expensive lists -->
<div v-for="item in items" v-memo="[item.id, item.status]" :key="item.id">
  <!-- Expensive content -->
</div>

<!-- ✅ Use v-once for static content -->
<div v-once>{{ expensiveCalculation }}</div>
```