---
title: Performance Monitoring & Optimization
tags: [performance, monitoring, optimization, web-vitals, enterprise]
globs: ["src/**/*.vue", "src/**/*.ts", "vite.config.ts"]
---

# Performance Monitoring & Optimization

## 🎯 Core Web Vitals Monitoring

### 1. Real User Monitoring (RUM) Setup
```typescript
// utils/performance.ts - Production-ready performance monitoring
interface PerformanceMetrics {
  // Core Web Vitals
  LCP?: number // Largest Contentful Paint
  FID?: number // First Input Delay  
  CLS?: number // Cumulative Layout Shift
  FCP?: number // First Contentful Paint
  TTFB?: number // Time to First Byte
  
  // Custom metrics
  routeChangeTime?: number
  componentMountTime?: number
  apiResponseTime?: number
  bundleSize?: number
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {}
  private observers: PerformanceObserver[] = []
  
  constructor(private reportEndpoint?: string) {
    this.initWebVitals()
    this.initCustomMetrics()
  }
  
  private initWebVitals() {
    // Largest Contentful Paint
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1] as PerformancePaintTiming
      this.metrics.LCP = lastEntry.startTime
      this.reportMetric('LCP', lastEntry.startTime)
    })
    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })
    this.observers.push(lcpObserver)
    
    // First Input Delay
    const fidObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      entries.forEach((entry: any) => {
        this.metrics.FID = entry.processingStart - entry.startTime
        this.reportMetric('FID', entry.processingStart - entry.startTime)
      })
    })
    fidObserver.observe({ entryTypes: ['first-input'] })
    this.observers.push(fidObserver)
    
    // Cumulative Layout Shift
    let clsValue = 0
    const clsObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries() as any[]) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
          this.metrics.CLS = clsValue
        }
      }
      this.reportMetric('CLS', clsValue)
    })
    clsObserver.observe({ entryTypes: ['layout-shift'] })
    this.observers.push(clsObserver)
  }
  
  private initCustomMetrics() {
    // Navigation timing
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      this.metrics.TTFB = navigation.responseStart - navigation.requestStart
      this.reportMetric('TTFB', this.metrics.TTFB)
    })
  }
  
  // Measure component performance
  measureComponentMount(componentName: string): () => void {
    const startTime = performance.now()
    
    return () => {
      const endTime = performance.now()
      const mountTime = endTime - startTime
      this.reportMetric(`component-mount-${componentName}`, mountTime)
    }
  }
  
  // Measure API call performance
  measureApiCall<T>(
    apiCall: () => Promise<T>,
    endpoint: string
  ): Promise<T> {
    const startTime = performance.now()
    
    return apiCall().finally(() => {
      const endTime = performance.now()
      const responseTime = endTime - startTime
      this.metrics.apiResponseTime = responseTime
      this.reportMetric(`api-${endpoint}`, responseTime)
    })
  }
  
  // Measure route change performance
  measureRouteChange(from: string, to: string): () => void {
    const startTime = performance.now()
    
    return () => {
      const endTime = performance.now()
      const changeTime = endTime - startTime
      this.reportMetric(`route-change-${from}-to-${to}`, changeTime)
    }
  }
  
  private reportMetric(name: string, value: number) {
    // Console logging for development
    if (import.meta.env.DEV) {
      console.log(`📊 Performance: ${name} = ${value.toFixed(2)}ms`)
    }
    
    // Send to analytics in production
    if (this.reportEndpoint && import.meta.env.PROD) {
      fetch(this.reportEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          metric: name,
          value,
          timestamp: Date.now(),
          userAgent: navigator.userAgent,
          url: window.location.href
        })
      }).catch(error => {
        console.warn('Failed to report performance metric:', error)
      })
    }
    
    // Google Analytics 4 integration
    if (typeof gtag !== 'undefined') {
      gtag('event', 'performance_metric', {
        metric_name: name,
        metric_value: Math.round(value),
        custom_parameter_1: window.location.pathname
      })
    }
  }
  
  // Get current metrics snapshot
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics }
  }
  
  // Clean up observers
  disconnect() {
    this.observers.forEach(observer => observer.disconnect())
    this.observers = []
  }
}

// Global performance monitor instance
export const performanceMonitor = new PerformanceMonitor(
  import.meta.env.VITE_PERFORMANCE_ENDPOINT
)

// Auto-cleanup on page unload
window.addEventListener('beforeunload', () => {
  performanceMonitor.disconnect()
})
```

### 2. Vue Component Performance Monitoring
```typescript
// composables/usePerformanceMonitoring.ts
export function usePerformanceMonitoring(componentName: string) {
  const startTime = ref<number>(0)
  const renderTime = ref<number>(0)
  const updateCount = ref<number>(0)
  
  // Measure component lifecycle
  onMounted(() => {
    const endMount = performanceMonitor.measureComponentMount(componentName)
    nextTick(() => {
      endMount()
      renderTime.value = performance.now() - startTime.value
    })
  })
  
  // Track re-renders
  onUpdated(() => {
    updateCount.value++
    if (updateCount.value > 10) {
      console.warn(`⚠️ Component ${componentName} has re-rendered ${updateCount.value} times`)
    }
  })
  
  // Start timing before setup
  onBeforeMount(() => {
    startTime.value = performance.now()
  })
  
  return {
    renderTime: readonly(renderTime),
    updateCount: readonly(updateCount)
  }
}

// Usage in components
<script setup lang="ts">
const { renderTime, updateCount } = usePerformanceMonitoring('UserDashboard')

// Log performance in development
watchEffect(() => {
  if (import.meta.env.DEV && renderTime.value > 0) {
    console.log(`Component render time: ${renderTime.value.toFixed(2)}ms`)
  }
})
</script>
```

## 🚀 Bundle Size Optimization

### 3. Intelligent Code Splitting
```typescript
// router/index.ts - Strategic route-based splitting
import { createRouter, createWebHistory } from 'vue-router'

// ✅ Split by feature domains, not individual pages
const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/auth',
      component: () => import('@/layouts/AuthLayout.vue'),
      children: [
        {
          path: 'login',
          component: () => import('@/pages/auth/LoginPage.vue')
        },
        {
          path: 'register', 
          component: () => import('@/pages/auth/RegisterPage.vue')
        }
      ]
    },
    {
      path: '/admin',
      component: () => import('@/layouts/AdminLayout.vue'),
      children: [
        {
          path: 'dashboard',
          component: () => import('@/pages/admin/DashboardPage.vue')
        },
        {
          path: 'users',
          // Preload likely next page
          component: () => import(
            /* webpackPreload: true */
            '@/pages/admin/UsersPage.vue'
          )
        }
      ]
    },
    {
      path: '/reports',
      component: () => import(
        /* webpackChunkName: "reports" */
        '@/modules/reports/ReportsLayout.vue'
      ),
      children: [
        {
          path: 'analytics',
          component: () => import(
            /* webpackChunkName: "reports" */
            '@/modules/reports/AnalyticsPage.vue'
          )
        }
      ]
    }
  ]
})

export default router
```

### 4. Vite Bundle Analysis & Optimization
```typescript
// vite.config.ts - Production optimization
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { analyzer } from 'vite-bundle-analyzer'

export default defineConfig({
  plugins: [
    vue(),
    // Bundle analysis in CI/CD
    process.env.ANALYZE && analyzer({
      analyzerMode: 'static',
      openAnalyzer: false,
      reportFilename: 'bundle-report.html'
    })
  ],
  
  build: {
    // Modern browser targets for smaller bundles
    target: 'es2020',
    
    // Optimize chunk splitting
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          // Vendor chunk optimization
          if (id.includes('node_modules')) {
            // Large libraries get their own chunks
            if (id.includes('vue') || id.includes('@vue')) {
              return 'vue-vendor'
            }
            if (id.includes('vuetify')) {
              return 'vuetify-vendor'
            }
            if (id.includes('pinia')) {
              return 'pinia-vendor'
            }
            if (id.includes('axios')) {
              return 'http-vendor'
            }
            // Everything else goes to vendor
            return 'vendor'
          }
          
          // Feature-based splitting
          if (id.includes('src/modules/reports')) {
            return 'reports-module'
          }
          if (id.includes('src/modules/admin')) {
            return 'admin-module'
          }
        }
      }
    },
    
    // Additional optimizations
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    
    // Source map for production debugging
    sourcemap: process.env.NODE_ENV === 'production' ? 'hidden' : true
  },
  
  // Performance optimizations
  optimizeDeps: {
    include: [
      'vue',
      'vue-router',
      'pinia',
      'axios'
    ],
    exclude: [
      // Large optional dependencies
      'chart.js',
      'monaco-editor'
    ]
  }
})
```

## 📊 Runtime Performance Optimization

### 5. Memory Leak Detection & Prevention
```typescript
// composables/useMemoryManagement.ts
interface MemoryMonitor {
  checkMemoryUsage: () => MemoryInfo | null
  trackComponentMemory: (componentName: string) => () => void
  detectLeaks: () => void
}

export function useMemoryManagement(): MemoryMonitor {
  const componentRegistry = new Map<string, number>()
  const intervalIds = new Set<number>()
  const timeoutIds = new Set<number>()
  
  const checkMemoryUsage = (): MemoryInfo | null => {
    if ('memory' in performance) {
      return (performance as any).memory
    }
    return null
  }
  
  const trackComponentMemory = (componentName: string) => {
    const startMemory = checkMemoryUsage()
    componentRegistry.set(componentName, componentRegistry.get(componentName) || 0 + 1)
    
    return () => {
      const endMemory = checkMemoryUsage()
      const instances = componentRegistry.get(componentName) || 0
      componentRegistry.set(componentName, Math.max(0, instances - 1))
      
      if (import.meta.env.DEV && startMemory && endMemory) {
        const memoryDiff = endMemory.usedJSHeapSize - startMemory.usedJSHeapSize
        if (memoryDiff > 1024 * 1024) { // 1MB threshold
          console.warn(`🔍 Memory: ${componentName} may have memory leak (+${(memoryDiff / 1024 / 1024).toFixed(2)}MB)`)
        }
      }
    }
  }
  
  const detectLeaks = () => {
    if (import.meta.env.DEV) {
      const activeComponents = Array.from(componentRegistry.entries())
        .filter(([_, count]) => count > 0)
      
      if (activeComponents.length > 0) {
        console.log('🔍 Active components:', activeComponents)
      }
    }
  }
  
  // Safe interval management
  const safeSetInterval = (callback: () => void, delay: number): number => {
    const id = setInterval(callback, delay)
    intervalIds.add(id)
    return id
  }
  
  const safeSetTimeout = (callback: () => void, delay: number): number => {
    const id = setTimeout(() => {
      callback()
      timeoutIds.delete(id)
    }, delay)
    timeoutIds.add(id)
    return id
  }
  
  // Cleanup all timers on unmount
  onBeforeUnmount(() => {
    intervalIds.forEach(id => clearInterval(id))
    timeoutIds.forEach(id => clearTimeout(id))
    intervalIds.clear()
    timeoutIds.clear()
  })
  
  return {
    checkMemoryUsage,
    trackComponentMemory,
    detectLeaks,
    safeSetInterval,
    safeSetTimeout
  }
}
```

### 6. Intelligent Caching Strategies
```typescript
// utils/cache.ts - Multi-level caching system
interface CacheOptions {
  ttl?: number // Time to live in milliseconds
  maxSize?: number // Maximum cache size
  staleWhileRevalidate?: boolean // Return stale data while fetching fresh
}

class IntelligentCache<T> {
  private cache = new Map<string, {
    data: T
    timestamp: number
    accessCount: number
    lastAccessed: number
  }>()
  
  constructor(private options: CacheOptions = {}) {
    const { maxSize = 100, ttl = 5 * 60 * 1000 } = options
    this.options = { maxSize, ttl, ...options }
  }
  
  set(key: string, value: T): void {
    // LRU eviction if cache is full
    if (this.cache.size >= this.options.maxSize!) {
      const lruKey = this.findLRUKey()
      if (lruKey) {
        this.cache.delete(lruKey)
      }
    }
    
    this.cache.set(key, {
      data: value,
      timestamp: Date.now(),
      accessCount: 0,
      lastAccessed: Date.now()
    })
  }
  
  get(key: string): T | null {
    const entry = this.cache.get(key)
    if (!entry) return null
    
    // Check if expired
    if (this.isExpired(entry)) {
      this.cache.delete(key)
      return null
    }
    
    // Update access statistics
    entry.accessCount++
    entry.lastAccessed = Date.now()
    
    return entry.data
  }
  
  async getOrFetch<K>(
    key: string,
    fetcher: () => Promise<T>,
    options?: { staleWhileRevalidate?: boolean }
  ): Promise<T> {
    const cached = this.get(key)
    
    if (cached) {
      // Stale-while-revalidate pattern
      if (options?.staleWhileRevalidate || this.options.staleWhileRevalidate) {
        const entry = this.cache.get(key)!
        const isStale = Date.now() - entry.timestamp > (this.options.ttl! * 0.8)
        
        if (isStale) {
          // Return stale data immediately, fetch fresh data in background
          fetcher().then(freshData => {
            this.set(key, freshData)
          }).catch(error => {
            console.warn('Background refresh failed:', error)
          })
        }
      }
      
      return cached
    }
    
    // Cache miss - fetch and cache
    const data = await fetcher()
    this.set(key, data)
    return data
  }
  
  private isExpired(entry: { timestamp: number }): boolean {
    return Date.now() - entry.timestamp > this.options.ttl!
  }
  
  private findLRUKey(): string | null {
    let lruKey: string | null = null
    let oldestAccess = Date.now()
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessed < oldestAccess) {
        oldestAccess = entry.lastAccessed
        lruKey = key
      }
    }
    
    return lruKey
  }
  
  clear(): void {
    this.cache.clear()
  }
  
  size(): number {
    return this.cache.size
  }
  
  // Get cache statistics
  getStats() {
    const entries = Array.from(this.cache.values())
    return {
      size: this.cache.size,
      totalAccesses: entries.reduce((sum, entry) => sum + entry.accessCount, 0),
      averageAge: entries.reduce((sum, entry) => sum + (Date.now() - entry.timestamp), 0) / entries.length || 0
    }
  }
}

// Pre-configured caches for different use cases
export const apiCache = new IntelligentCache<any>({
  ttl: 5 * 60 * 1000, // 5 minutes
  maxSize: 200,
  staleWhileRevalidate: true
})

export const staticDataCache = new IntelligentCache<any>({
  ttl: 30 * 60 * 1000, // 30 minutes
  maxSize: 100
})

export const userDataCache = new IntelligentCache<any>({
  ttl: 2 * 60 * 1000, // 2 minutes
  maxSize: 50
})
```

## 🔍 Performance Debugging Tools

### 7. Development Performance Dashboard
```vue
<!-- components/DevPerformanceDashboard.vue -->
<template>
  <div v-if="isDev" class="performance-dashboard">
    <div class="dashboard-header">
      <h3>🚀 Performance Dashboard</h3>
      <button @click="toggleExpanded">
        {{ isExpanded ? 'Collapse' : 'Expand' }}
      </button>
    </div>
    
    <div v-if="isExpanded" class="dashboard-content">
      <div class="metrics-grid">
        <div class="metric-card">
          <h4>Core Web Vitals</h4>
          <div>LCP: {{ metrics.LCP?.toFixed(2) }}ms</div>
          <div>FID: {{ metrics.FID?.toFixed(2) }}ms</div>
          <div>CLS: {{ metrics.CLS?.toFixed(3) }}</div>
        </div>
        
        <div class="metric-card">
          <h4>Memory Usage</h4>
          <div v-if="memoryInfo">
            <div>Used: {{ (memoryInfo.usedJSHeapSize / 1024 / 1024).toFixed(2) }}MB</div>
            <div>Total: {{ (memoryInfo.totalJSHeapSize / 1024 / 1024).toFixed(2) }}MB</div>
            <div>Limit: {{ (memoryInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2) }}MB</div>
          </div>
        </div>
        
        <div class="metric-card">
          <h4>Cache Statistics</h4>
          <div>API Cache: {{ apiCacheStats.size }} items</div>
          <div>Hit Rate: {{ hitRate.toFixed(1) }}%</div>
          <div>Avg Age: {{ (apiCacheStats.averageAge / 1000).toFixed(1) }}s</div>
        </div>
        
        <div class="metric-card">
          <h4>Bundle Info</h4>
          <div>Chunks Loaded: {{ loadedChunks.length }}</div>
          <div>Total Size: {{ totalBundleSize }}KB</div>
        </div>
      </div>
      
      <div class="performance-chart">
        <canvas ref="chartCanvas" width="400" height="200"></canvas>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { performanceMonitor } from '@/utils/performance'
import { apiCache } from '@/utils/cache'

const isDev = import.meta.env.DEV
const isExpanded = ref(false)
const metrics = ref<PerformanceMetrics>({})
const memoryInfo = ref<MemoryInfo | null>(null)
const apiCacheStats = ref({ size: 0, totalAccesses: 0, averageAge: 0 })
const loadedChunks = ref<string[]>([])
const hitRate = ref(0)
const totalBundleSize = ref(0)

const toggleExpanded = () => {
  isExpanded.value = !isExpanded.value
}

// Update metrics periodically
onMounted(() => {
  const updateMetrics = () => {
    metrics.value = performanceMonitor.getMetrics()
    memoryInfo.value = performance.memory || null
    apiCacheStats.value = apiCache.getStats()
    
    // Calculate hit rate (simplified)
    const stats = apiCache.getStats()
    hitRate.value = stats.totalAccesses > 0 ? (stats.size / stats.totalAccesses) * 100 : 0
    
    // Get loaded chunks info
    if ('webpack' in window || 'vite' in window) {
      // Implementation depends on bundler
      loadedChunks.value = Object.keys(window.__viteClientCache || {})
    }
  }
  
  updateMetrics()
  const interval = setInterval(updateMetrics, 2000)
  
  onBeforeUnmount(() => {
    clearInterval(interval)
  })
})
</script>

<style scoped>
.performance-dashboard {
  position: fixed;
  top: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 10px;
  border-radius: 8px;
  font-family: monospace;
  font-size: 12px;
  z-index: 9999;
  max-width: 500px;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin: 10px 0;
}

.metric-card {
  background: rgba(255, 255, 255, 0.1);
  padding: 8px;
  border-radius: 4px;
}

.metric-card h4 {
  margin: 0 0 5px 0;
  color: #4CAF50;
}
</style>
```

These performance monitoring patterns provide comprehensive insights into your Vue 3 application's performance, helping identify bottlenecks and optimize user experience systematically.