---
title: TypeScript Excellence for Vue 3
tags: [typescript, type-safety, enterprise, vue3]
globs: ["src/**/*.ts", "src/**/*.vue", "*.config.ts"]
---

# TypeScript Excellence for Vue 3

## üéØ Strict Type Safety Configuration

### Essential TypeScript Config
```json
// tsconfig.json - Enterprise-grade configuration
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    
    // Vue-specific
    "jsx": "preserve",
    "module": "ESNext",
    "target": "ES2020",
    "moduleResolution": "node",
    "allowImportingTsExtensions": false,
    "isolatedModules": true,
    "skipLibCheck": true,
    
    // Path mapping for clean imports
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/components/*": ["src/components/*"],
      "@/composables/*": ["src/composables/*"],
      "@/stores/*": ["src/stores/*"],
      "@/utils/*": ["src/utils/*"],
      "@/types/*": ["src/types/*"]
    }
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.vue",
    "src/**/*.d.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
```

## üèóÔ∏è Advanced Type Patterns

### 1. Branded Types for Domain Safety
```typescript
// ‚úÖ Excellent: Prevent mixing different ID types
type Brand<T, K> = T & { __brand: K }

type UserId = Brand<string, 'UserId'>
type ProductId = Brand<string, 'ProductId'>
type Email = Brand<string, 'Email'>

// Factory functions with validation
function createUserId(id: string): UserId {
  if (!id || id.length < 3) {
    throw new Error('Invalid user ID')
  }
  return id as UserId
}

function createEmail(email: string): Email {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(email)) {
    throw new Error('Invalid email format')
  }
  return email as Email
}

// Type-safe usage
function getUser(id: UserId): Promise<User> {
  return api.get(`/users/${id}`)
}

// ‚ùå This would be a TypeScript error
const productId: ProductId = 'prod-123' as ProductId
getUser(productId) // Error: Argument of type 'ProductId' is not assignable to parameter of type 'UserId'
```

### 2. Discriminated Unions for State Management
```typescript
// ‚úÖ Professional: Type-safe state modeling
type AsyncState<T, E = Error> = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: E }

// Type-safe state handlers
function handleAsyncState<T>(state: AsyncState<T>) {
  switch (state.status) {
    case 'idle':
      return 'Not started'
    case 'loading':
      return 'Loading...'
    case 'success':
      return `Loaded: ${state.data}` // TypeScript knows 'data' exists
    case 'error':
      return `Error: ${state.error.message}` // TypeScript knows 'error' exists
    default:
      // TypeScript ensures exhaustive checking
      const _exhaustive: never = state
      return _exhaustive
  }
}

// Advanced: Generic async state composable
function useAsyncState<T, E = Error>(
  asyncFn: () => Promise<T>
): {
  state: Ref<AsyncState<T, E>>
  execute: () => Promise<void>
  reset: () => void
} {
  const state = ref<AsyncState<T, E>>({ status: 'idle' })
  
  const execute = async () => {
    state.value = { status: 'loading' }
    try {
      const data = await asyncFn()
      state.value = { status: 'success', data }
    } catch (error) {
      state.value = { status: 'error', error: error as E }
    }
  }
  
  const reset = () => {
    state.value = { status: 'idle' }
  }
  
  return { state, execute, reset }
}
```

### 3. Advanced Generic Constraints
```typescript
// ‚úÖ Enterprise: Sophisticated generic patterns
interface Identifiable {
  id: string
}

interface Timestamped {
  createdAt: Date
  updatedAt: Date
}

interface Auditable extends Timestamped {
  createdBy: UserId
  updatedBy: UserId
}

// Generic repository with constraints
interface Repository<T extends Identifiable> {
  findById(id: string): Promise<T | null>
  findAll(query?: Partial<T>): Promise<T[]>
  create(data: Omit<T, 'id' | keyof Timestamped>): Promise<T>
  update(id: string, data: Partial<Omit<T, 'id' | keyof Auditable>>): Promise<T>
  delete(id: string): Promise<void>
}

// Conditional types for smart APIs
type CreatePayload<T> = T extends Auditable
  ? Omit<T, 'id' | keyof Auditable>
  : T extends Timestamped
  ? Omit<T, 'id' | keyof Timestamped>
  : Omit<T, 'id'>

type UpdatePayload<T> = T extends Auditable
  ? Partial<Omit<T, 'id' | keyof Auditable>>
  : T extends Timestamped
  ? Partial<Omit<T, 'id' | 'createdAt'>>
  : Partial<Omit<T, 'id'>>

// Usage
interface User extends Identifiable, Auditable {
  name: string
  email: Email
  role: UserRole
}

// TypeScript automatically infers correct payload types
const createUser = (payload: CreatePayload<User>) => {
  // payload has type: { name: string; email: Email; role: UserRole }
  // No id, createdAt, updatedAt, createdBy, updatedBy required
}
```

## üîí Type-Safe Vue Components

### 4. Strict Component Props and Emits
```typescript
// ‚úÖ Professional: Comprehensive component typing
interface User {
  id: UserId
  name: string
  email: Email
  avatar?: string
}

interface UserCardProps {
  user: User
  size?: 'small' | 'medium' | 'large'
  showActions?: boolean
  readonly?: boolean
}

interface UserCardEmits {
  'user:edit': [user: User]
  'user:delete': [userId: UserId]
  'user:contact': [email: Email]
  'update:user': [user: User] // For v-model
}

// Component with strict typing
const UserCard = defineComponent({
  props: {
    user: {
      type: Object as PropType<User>,
      required: true
    },
    size: {
      type: String as PropType<'small' | 'medium' | 'large'>,
      default: 'medium'
    },
    showActions: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    'user:edit': (user: User) => user && typeof user.id === 'string',
    'user:delete': (userId: UserId) => typeof userId === 'string',
    'user:contact': (email: Email) => typeof email === 'string',
    'update:user': (user: User) => user && typeof user.id === 'string'
  } as UserCardEmits,
  setup(props, { emit }) {
    // Type-safe prop access and emit calls
    const handleEdit = () => {
      if (!props.readonly) {
        emit('user:edit', props.user)
      }
    }
    
    return { handleEdit }
  }
})

// Script setup alternative with even better DX
<script setup lang="ts">
interface Props {
  user: User
  size?: 'small' | 'medium' | 'large'
  showActions?: boolean
  readonly?: boolean
}

interface Emits {
  'user:edit': [user: User]
  'user:delete': [userId: UserId]
  'user:contact': [email: Email]
}

const props = withDefaults(defineProps<Props>(), {
  size: 'medium',
  showActions: true,
  readonly: false
})

const emit = defineEmits<Emits>()

// Fully type-safe usage
const handleEdit = () => {
  if (!props.readonly) {
    emit('user:edit', props.user)
  }
}
</script>
```

### 5. Type-Safe Composables
```typescript
// ‚úÖ Advanced: Generic composables with proper typing
interface UseAsyncOptions<T> {
  immediate?: boolean
  onSuccess?: (data: T) => void
  onError?: (error: Error) => void
  transform?: <U>(data: T) => U
}

function useAsync<T>(
  asyncFn: () => Promise<T>,
  options: UseAsyncOptions<T> = {}
) {
  const {
    immediate = false,
    onSuccess,
    onError,
    transform
  } = options
  
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  const isLoading = ref(false)
  
  const execute = async (): Promise<T | null> => {
    isLoading.value = true
    error.value = null
    
    try {
      let result = await asyncFn()
      
      if (transform) {
        result = transform(result) as T
      }
      
      data.value = result
      onSuccess?.(result)
      return result
    } catch (err) {
      const errorObj = err as Error
      error.value = errorObj
      onError?.(errorObj)
      return null
    } finally {
      isLoading.value = false
    }
  }
  
  if (immediate) {
    execute()
  }
  
  return {
    data: readonly(data),
    error: readonly(error),
    isLoading: readonly(isLoading),
    execute
  } as const
}

// Usage with full type inference
const { data, error, isLoading, execute } = useAsync(
  () => api.getUsers(),
  {
    immediate: true,
    onSuccess: (users) => {
      // users is properly typed as User[]
      console.log(`Loaded ${users.length} users`)
    },
    transform: (users) => users.filter(user => user.role === 'admin')
  }
)
```

## üõ°Ô∏è Type Guards and Validation

### 6. Runtime Type Validation
```typescript
// ‚úÖ Production-ready: Runtime type checking
function isString(value: unknown): value is string {
  return typeof value === 'string'
}

function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value)
}

function isEmail(value: unknown): value is Email {
  return isString(value) && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)
}

function isUser(value: unknown): value is User {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'name' in value &&
    'email' in value &&
    isString((value as any).id) &&
    isString((value as any).name) &&
    isEmail((value as any).email)
  )
}

// Generic validation helper
function validate<T>(
  value: unknown,
  guard: (value: unknown) => value is T,
  errorMessage: string
): T {
  if (guard(value)) {
    return value
  }
  throw new Error(errorMessage)
}

// Usage in API responses
const validateApiResponse = <T>(
  response: unknown,
  guard: (value: unknown) => value is T
): T => {
  return validate(
    response,
    guard,
    'Invalid API response format'
  )
}

// Zod integration for complex validation
import { z } from 'zod'

const UserSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1),
  email: z.string().email(),
  role: z.enum(['admin', 'user', 'guest'])
})

type UserFromSchema = z.infer<typeof UserSchema>

const validateUser = (data: unknown): User => {
  return UserSchema.parse(data) as User
}
```

## üì¶ Module and Namespace Organization

### 7. Ambient Module Declarations
```typescript
// types/global.d.ts - Global type definitions
declare global {
  interface Window {
    gtag?: (...args: any[]) => void
    dataLayer?: any[]
  }
  
  // Vue router meta typing
  interface RouteMeta {
    requiresAuth?: boolean
    roles?: UserRole[]
    title?: string
    layout?: 'default' | 'auth' | 'admin'
  }
}

// Module augmentation for Vue
declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $api: ApiService
    $toast: ToastService
    $auth: AuthService
  }
  
  interface GlobalComponents {
    Icon: typeof Icon
    Loader: typeof Loader
    ErrorBoundary: typeof ErrorBoundary
  }
}

// Vite environment variables
interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string
  readonly VITE_API_BASE_URL: string
  readonly VITE_AUTH_DOMAIN: string
  readonly VITE_ENABLE_ANALYTICS: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

export {}
```

### 8. Smart Type Utilities
```typescript
// types/utils.ts - Reusable type utilities
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

export type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P]
}

export type Prettify<T> = {
  [K in keyof T]: T[K]
} & {}

export type UnionToIntersection<U> = 
  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never

export type DistributiveOmit<T, K extends keyof any> = T extends any 
  ? Omit<T, K> 
  : never

// API response utilities
export type ApiResponse<T> = {
  data: T
  message: string
  success: boolean
}

export type PaginatedResponse<T> = ApiResponse<T[]> & {
  pagination: {
    page: number
    limit: number
    total: number
    pages: number
  }
}

// Form handling utilities
export type FormField<T> = {
  value: T
  error: string | null
  touched: boolean
  required: boolean
}

export type FormState<T extends Record<string, any>> = {
  [K in keyof T]: FormField<T[K]>
}

// Event handler utilities
export type EventHandler<T extends Event = Event> = (event: T) => void | Promise<void>

export type AsyncEventHandler<T extends Event = Event> = (event: T) => Promise<void>
```

## ‚ùå TypeScript Anti-Patterns to Avoid

```typescript
// ‚ùå NEVER: Using 'any' without proper justification
const data: any = await api.getData()

// ‚úÖ GOOD: Proper typing with validation
const data = validateApiResponse(await api.getData(), isUserArray)

// ‚ùå BAD: Type assertions without validation
const user = response as User

// ‚úÖ GOOD: Safe type checking
const user = isUser(response) ? response : null

// ‚ùå BAD: Overly complex generic constraints
function process<T extends Record<string, any> & { id: number } & Partial<{ name: string }>>

// ‚úÖ GOOD: Clear, focused interfaces
interface ProcessableEntity {
  id: number
  name?: string
}
function process<T extends ProcessableEntity>

// ‚ùå BAD: Mutation of readonly types
function mutateReadonly(data: readonly string[]) {
  (data as string[]).push('new item') // Type assertion to bypass readonly
}

// ‚úÖ GOOD: Respect immutability
function addToReadonly(data: readonly string[], item: string): readonly string[] {
  return [...data, item]
}
```

These TypeScript patterns ensure maximum type safety, excellent developer experience, and robust error catching at compile time, leading to more maintainable and reliable Vue 3 applications.