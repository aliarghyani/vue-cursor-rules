---
description: Vue 3 Composition API fundamentals and best practices
globs: ["**/*.vue", "**/*.ts"]
alwaysApply: true
---
# Vue 3 Fundamentals

**Role:** You are a Vue 3 expert specializing in modern component architecture.

**Core Rules:**
- Always use `<script setup>` syntax
- Type props with `defineProps<T>()`
- Use `ref()` for primitives, `reactive()` sparingly
- Prefer `computed()` for derived state
- Access `.value` explicitly in script context

**Chain-of-Thought:** Think step-by-step: 1. Analyze component needs 2. Define props/emits interface 3. Plan reactive state 4. Implement logic

**Note:** These patterns are UI-framework neutral; adapt templates for kits like Vuetify/Quasar while preserving composition logic.

## Workflow Chain: Build a Reactive Component

**Full Task:** Create a counter component with props and events.

**Step 1:** Define interface
```typescript
interface Props { initialCount?: number }
interface Emits { update: [value: number] }
```

**Step 2:** Setup reactive state
```typescript
const count = ref(props.initialCount ?? 0)
const doubleCount = computed(() => count.value * 2)
```

**Step 3:** Implement methods and emit
```vue
<script setup lang="ts">
import { ref, computed } from 'vue'

interface Props { initialCount?: number }
interface Emits { update: [value: number] }

const props = withDefaults(defineProps<Props>(), { initialCount: 0 })
const emit = defineEmits<Emits>()

const count = ref(props.initialCount)
const doubleCount = computed(() => count.value * 2)

const increment = () => {
  count.value++
  emit('update', count.value)
}
</script>

<template>
  <div>
    <p>Count: {{ count }} (Double: {{ doubleCount }})</p>
    <button @click="increment">Increment</button>
  </div>
</template>
```

## Composition API Patterns

Always use Composition API with `<script setup>`:

```vue
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

// Reactive state
const count = ref(0)
const message = ref('')

// Computed properties
const doubleCount = computed(() => count.value * 2)

// Methods
const increment = () => count.value++

// Lifecycle
onMounted(() => {
  console.log('Component mounted')
})
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Double: {{ doubleCount }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>
```

## Props and Emits

```vue
<script setup lang="ts">
interface Props {
  title: string
  count?: number
}

interface Emits {
  update: [value: number]
  close: []
}

const props = withDefaults(defineProps<Props>(), {
  count: 0
})

const emit = defineEmits<Emits>()

const handleUpdate = (value: number) => {
  emit('update', value)
}
</script>
```

## Reactivity Best Practices

- Use `ref()` for primitives
- Use `reactive()` for objects (sparingly)
- Always access `.value` in script
- Use `computed()` for derived state
- Use `watch()` for side effects

```typescript
// Good
const user = ref<User | null>(null)
const isLoggedIn = computed(() => !!user.value)

// Avoid
const state = reactive({ user: null, isLoggedIn: false })
```

## UI Kit Adaptations

**Core composition logic stays identical across all UI frameworks:**

- **Tailwind UI:** Use utility classes with semantic HTML
  ```vue
  <button @click="increment" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
    Increment
  </button>
  ```

- **Vuetify:** Replace with Material components
  ```vue
  <v-btn @click="increment" color="primary">Increment</v-btn>
  ```

- **Quasar:** Use mobile-optimized components
  ```vue
  <q-btn @click="increment" color="primary" label="Increment" />
  ```

- **Element Plus:** Leverage rich component library
  ```vue
  <el-button @click="increment" type="primary">Increment</el-button>
  ```

*Key principle: Reactivity (`ref`, `computed`, `watch`) and composition patterns remain unchangedâ€”only template syntax adapts. See ui-kits-guide.mdc for comprehensive integration patterns.*