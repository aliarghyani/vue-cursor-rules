---
title: Advanced Vue 3 Composition Patterns
tags: [vue3, composition-api, patterns, enterprise, architecture]
globs: ["src/**/*.vue", "src/**/*.ts", "src/composables/**/*.ts"]
---

# Advanced Vue 3 Composition Patterns

## üéØ Composable Design Patterns

### 1. Factory Pattern for Composables
```typescript
// ‚úÖ Excellent: Configurable composable factory
function createAsyncState<T>(fetcher: () => Promise<T>, options: {
  immediate?: boolean
  resetOnParamsChange?: boolean
  retryCount?: number
} = {}) {
  const { immediate = true, resetOnParamsChange = true, retryCount = 3 } = options
  
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  const isLoading = ref(false)
  const retryAttempts = ref(0)
  
  const execute = async () => {
    if (isLoading.value) return
    
    isLoading.value = true
    error.value = null
    
    try {
      data.value = await fetcher()
      retryAttempts.value = 0
    } catch (err) {
      error.value = err as Error
      
      if (retryAttempts.value < retryCount) {
        retryAttempts.value++
        setTimeout(execute, Math.pow(2, retryAttempts.value) * 1000) // Exponential backoff
      }
    } finally {
      isLoading.value = false
    }
  }
  
  if (immediate) {
    execute()
  }
  
  return {
    data: readonly(data),
    error: readonly(error),
    isLoading: readonly(isLoading),
    execute,
    refresh: execute
  }
}

// Usage
const { data: users, isLoading, error, refresh } = createAsyncState(
  () => api.getUsers(),
  { immediate: true, retryCount: 3 }
)
```

### 2. Dependency Injection Pattern
```typescript
// ‚úÖ Enterprise-grade: Service injection
const ServiceKey = Symbol('ServiceKey') as InjectionKey<ApiService>

// Provider setup (in main.ts or parent component)
app.provide(ServiceKey, new ApiService())

// Consumer composable
function useService() {
  const service = inject(ServiceKey)
  if (!service) {
    throw new Error('Service not provided. Did you forget to provide ServiceKey?')
  }
  return service
}

// Advanced: Type-safe provider factory
function createProvider<T>(key: InjectionKey<T>) {
  return {
    provide: (value: T) => provide(key, value),
    inject: () => {
      const injected = inject(key)
      if (!injected) {
        throw new Error(`${key.description || 'Service'} not provided`)
      }
      return injected
    },
    injectOptional: () => inject(key, null)
  }
}
```

### 3. State Machine Pattern
```typescript
// ‚úÖ Robust: Finite state machine for complex flows
type State = 'idle' | 'loading' | 'success' | 'error' | 'retrying'
type Event = 'START' | 'SUCCESS' | 'ERROR' | 'RETRY' | 'RESET'

interface StateMachine {
  state: Ref<State>
  can: (event: Event) => boolean
  transition: (event: Event, payload?: any) => void
}

function useStateMachine(initialState: State = 'idle'): StateMachine {
  const state = ref<State>(initialState)
  
  const transitions: Record<State, Partial<Record<Event, State>>> = {
    idle: { START: 'loading' },
    loading: { SUCCESS: 'success', ERROR: 'error' },
    success: { START: 'loading', RESET: 'idle' },
    error: { RETRY: 'retrying', RESET: 'idle', START: 'loading' },
    retrying: { SUCCESS: 'success', ERROR: 'error' }
  }
  
  const can = (event: Event): boolean => {
    return !!(transitions[state.value]?.[event])
  }
  
  const transition = (event: Event, payload?: any) => {
    const nextState = transitions[state.value]?.[event]
    if (nextState) {
      state.value = nextState
    } else {
      console.warn(`Invalid transition: ${state.value} + ${event}`)
    }
  }
  
  return { state: readonly(state), can, transition }
}

// Usage in async operations
function useAsyncOperation<T>(operation: () => Promise<T>) {
  const { state, can, transition } = useStateMachine()
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  
  const execute = async () => {
    if (!can('START')) return
    
    transition('START')
    try {
      data.value = await operation()
      transition('SUCCESS')
    } catch (err) {
      error.value = err as Error
      transition('ERROR')
    }
  }
  
  return { state, data, error, execute, canRetry: () => can('RETRY') }
}
```

## üèóÔ∏è Advanced Architectural Patterns

### 4. Repository Pattern with Cache
```typescript
// ‚úÖ Enterprise: Repository with intelligent caching
interface Repository<T, K = string> {
  find(id: K): Promise<T | null>
  findAll(query?: Record<string, any>): Promise<T[]>
  create(data: Partial<T>): Promise<T>
  update(id: K, data: Partial<T>): Promise<T>
  delete(id: K): Promise<void>
}

class CachedRepository<T extends { id: K }, K = string> implements Repository<T, K> {
  private cache = new Map<string, { data: T; timestamp: number }>()
  private ttl = 5 * 60 * 1000 // 5 minutes
  
  constructor(
    private api: Repository<T, K>,
    private keySelector: (item: T) => K = (item) => item.id
  ) {}
  
  private getCacheKey(method: string, ...args: any[]): string {
    return `${method}:${JSON.stringify(args)}`
  }
  
  private isValidCache(timestamp: number): boolean {
    return Date.now() - timestamp < this.ttl
  }
  
  async find(id: K): Promise<T | null> {
    const cacheKey = this.getCacheKey('find', id)
    const cached = this.cache.get(cacheKey)
    
    if (cached && this.isValidCache(cached.timestamp)) {
      return cached.data
    }
    
    const result = await this.api.find(id)
    if (result) {
      this.cache.set(cacheKey, { data: result, timestamp: Date.now() })
    }
    
    return result
  }
  
  async findAll(query?: Record<string, any>): Promise<T[]> {
    const cacheKey = this.getCacheKey('findAll', query)
    const cached = this.cache.get(cacheKey)
    
    if (cached && this.isValidCache(cached.timestamp)) {
      return cached.data as T[]
    }
    
    const result = await this.api.findAll(query)
    this.cache.set(cacheKey, { data: result as any, timestamp: Date.now() })
    
    return result
  }
  
  async create(data: Partial<T>): Promise<T> {
    const result = await this.api.create(data)
    this.invalidateCache()
    return result
  }
  
  async update(id: K, data: Partial<T>): Promise<T> {
    const result = await this.api.update(id, data)
    this.invalidateCache()
    return result
  }
  
  async delete(id: K): Promise<void> {
    await this.api.delete(id)
    this.invalidateCache()
  }
  
  private invalidateCache(): void {
    this.cache.clear()
  }
}

// Composable wrapper
function useRepository<T extends { id: K }, K = string>(
  repositoryFactory: () => Repository<T, K>
) {
  const repository = repositoryFactory()
  
  return {
    find: (id: K) => repository.find(id),
    findAll: (query?: Record<string, any>) => repository.findAll(query),
    create: (data: Partial<T>) => repository.create(data),
    update: (id: K, data: Partial<T>) => repository.update(id, data),
    delete: (id: K) => repository.delete(id)
  }
}
```

### 5. Event Bus Pattern with Type Safety
```typescript
// ‚úÖ Advanced: Type-safe event system
type EventMap = {
  'user:login': { user: User; timestamp: number }
  'user:logout': { reason: string }
  'notification:show': { message: string; type: 'success' | 'error' | 'warning' }
  'data:refresh': { entity: string }
}

class TypedEventBus<T extends Record<string, any> = EventMap> {
  private listeners = new Map<keyof T, Set<Function>>()
  
  on<K extends keyof T>(event: K, listener: (payload: T[K]) => void): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    
    this.listeners.get(event)!.add(listener)
    
    // Return unsubscribe function
    return () => {
      this.listeners.get(event)?.delete(listener)
    }
  }
  
  emit<K extends keyof T>(event: K, payload: T[K]): void {
    this.listeners.get(event)?.forEach(listener => {
      try {
        listener(payload)
      } catch (error) {
        console.error(`Error in event listener for ${String(event)}:`, error)
      }
    })
  }
  
  off<K extends keyof T>(event: K, listener?: (payload: T[K]) => void): void {
    if (listener) {
      this.listeners.get(event)?.delete(listener)
    } else {
      this.listeners.delete(event)
    }
  }
}

// Global event bus instance
const eventBus = new TypedEventBus()

// Composable for event handling
function useEventBus() {
  const activeListeners = new Set<() => void>()
  
  const on = <K extends keyof EventMap>(
    event: K, 
    listener: (payload: EventMap[K]) => void
  ) => {
    const unsubscribe = eventBus.on(event, listener)
    activeListeners.add(unsubscribe)
    return unsubscribe
  }
  
  const emit = <K extends keyof EventMap>(event: K, payload: EventMap[K]) => {
    eventBus.emit(event, payload)
  }
  
  // Auto cleanup on unmount
  onBeforeUnmount(() => {
    activeListeners.forEach(unsubscribe => unsubscribe())
    activeListeners.clear()
  })
  
  return { on, emit }
}
```

## üöÄ Performance Optimization Patterns

### 6. Resource Management Pattern
```typescript
// ‚úÖ Professional: Resource lifecycle management
interface Resource {
  cleanup(): void | Promise<void>
}

class ResourceManager {
  private resources = new Set<Resource>()
  
  register<T extends Resource>(resource: T): T {
    this.resources.add(resource)
    return resource
  }
  
  async cleanup(): Promise<void> {
    const cleanupPromises = Array.from(this.resources).map(resource => 
      Promise.resolve(resource.cleanup())
    )
    
    await Promise.allSettled(cleanupPromises)
    this.resources.clear()
  }
}

function useResourceManager() {
  const manager = new ResourceManager()
  
  const register = <T extends Resource>(resource: T): T => {
    return manager.register(resource)
  }
  
  onBeforeUnmount(() => {
    manager.cleanup()
  })
  
  return { register }
}

// Usage with HTTP requests
function useAbortableRequest() {
  const { register } = useResourceManager()
  
  const createRequest = <T>(requestFn: (signal: AbortSignal) => Promise<T>) => {
    const controller = new AbortController()
    
    // Register for auto-cleanup
    register({
      cleanup: () => controller.abort()
    })
    
    return requestFn(controller.signal)
  }
  
  return { createRequest }
}
```

### 7. Memoization and Caching Patterns
```typescript
// ‚úÖ Performance: Advanced memoization
function useMemoizedComputed<T>(
  getter: () => T,
  deps: Ref<any>[] = [],
  options: { maxAge?: number; maxSize?: number } = {}
) {
  const { maxAge = Infinity, maxSize = 100 } = options
  const cache = new Map<string, { value: T; timestamp: number }>()
  
  return computed(() => {
    const key = deps.map(dep => dep.value).join('|')
    const cached = cache.get(key)
    
    if (cached && Date.now() - cached.timestamp < maxAge) {
      return cached.value
    }
    
    const value = getter()
    
    // Implement LRU eviction
    if (cache.size >= maxSize) {
      const firstKey = cache.keys().next().value
      cache.delete(firstKey)
    }
    
    cache.set(key, { value, timestamp: Date.now() })
    return value
  })
}

// Heavy computation example
function useExpensiveCalculation(data: Ref<number[]>) {
  return useMemoizedComputed(
    () => data.value.reduce((sum, n) => sum + Math.pow(n, 2), 0),
    [data],
    { maxAge: 5000, maxSize: 50 }
  )
}
```

## ‚ùå Anti-Patterns to Avoid

### Common Vue 3 Anti-Patterns
```typescript
// ‚ùå BAD: Reactive object mutation without proper reactivity
const state = reactive({ users: [] })
state.users = newUsers // Loses reactivity tracking

// ‚úÖ GOOD: Proper reactive updates
const state = reactive({ users: [] })
state.users.splice(0, state.users.length, ...newUsers)

// ‚ùå BAD: Using ref for objects that need deep reactivity
const complexObject = ref({ nested: { data: [] } })
complexObject.value.nested.data.push(item) // May not trigger updates

// ‚úÖ GOOD: Use reactive for complex objects
const complexObject = reactive({ nested: { data: [] } })
complexObject.nested.data.push(item)

// ‚ùå BAD: Creating refs in computed
const badComputed = computed(() => {
  return ref(expensiveCalculation()) // Creates new ref every time
})

// ‚úÖ GOOD: Return computed values directly
const goodComputed = computed(() => {
  return expensiveCalculation()
})

// ‚ùå BAD: Unnecessary watchers for simple derivations
watch([a, b], ([newA, newB]) => {
  sum.value = newA + newB
})

// ‚úÖ GOOD: Use computed for derived state
const sum = computed(() => a.value + b.value)
```

## üé® Component Design Patterns

### 8. Compound Component Pattern
```typescript
// ‚úÖ Advanced: Compound components with context
interface TabsContext {
  activeTab: Ref<string>
  registerTab: (id: string) => void
  activateTab: (id: string) => void
}

const TabsContextKey = Symbol('TabsContext') as InjectionKey<TabsContext>

// Parent component
function useTabs(defaultTab?: string) {
  const activeTab = ref(defaultTab || '')
  const registeredTabs = new Set<string>()
  
  const registerTab = (id: string) => {
    registeredTabs.add(id)
    if (!activeTab.value) {
      activeTab.value = id
    }
  }
  
  const activateTab = (id: string) => {
    if (registeredTabs.has(id)) {
      activeTab.value = id
    }
  }
  
  const context: TabsContext = {
    activeTab,
    registerTab,
    activateTab
  }
  
  provide(TabsContextKey, context)
  
  return context
}

// Child components use context
function useTabContext() {
  const context = inject(TabsContextKey)
  if (!context) {
    throw new Error('useTabContext must be used within a Tabs component')
  }
  return context
}
```

These patterns provide a solid foundation for building enterprise-grade Vue 3 applications with optimal performance, maintainability, and scalability.