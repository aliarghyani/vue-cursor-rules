---
title: Vue 3 Code Structure Patterns
tags: [structure, patterns, code-generation]
globs: ["src/**/*.vue", "src/**/*.ts", "src/**/*.js"]
---

# Vue 3 Code Structure Patterns

## Component Structure Template
```vue
<template>
  <div class="component-name">
    <!-- Use semantic HTML with proper accessibility -->
    <header v-if="title" class="component-name__header">
      <h2>{{ title }}</h2>
    </header>
    
    <main class="component-name__content">
      <slot />
    </main>
    
    <!-- Loading and error states -->
    <div v-if="loading" class="loading" aria-live="polite">Loading...</div>
    <div v-if="error" class="error" role="alert">{{ error }}</div>
  </div>
</template>

<script setup lang="ts">
interface Props {
  title?: string
  loading?: boolean
  error?: string
}

interface Emits {
  (e: 'action', payload: any): void
}

const props = withDefaults(defineProps<Props>(), {
  title: '',
  loading: false,
  error: ''
})

const emit = defineEmits<Emits>()

// Component logic here
</script>

<style scoped>
.component-name {
  /* Component styles */
}
</style>
```

## Form Component Pattern
```vue
<script setup lang="ts">
interface FormData {
  email: string
  password: string
}

interface FormErrors {
  email?: string
  password?: string
}

const form = reactive<FormData>({ email: '', password: '' })
const errors = reactive<FormErrors>({})
const isSubmitting = ref(false)

const validate = (): boolean => {
  errors.email = !form.email ? 'Required' : undefined
  errors.password = form.password.length < 8 ? 'Min 8 characters' : undefined
  return !Object.values(errors).some(Boolean)
}

const handleSubmit = async () => {
  if (!validate()) return
  
  isSubmitting.value = true
  try {
    await submitForm(form)
    emit('success', form)
  } catch (error) {
    emit('error', error)
  } finally {
    isSubmitting.value = false
  }
}
</script>
```

## List Component Pattern
```vue
<script setup lang="ts">
interface Item {
  id: string
  name: string
  [key: string]: any
}

interface Props {
  items: Item[]
  searchable?: boolean
  loading?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  searchable: true,
  loading: false
})

const searchQuery = ref('')

const filteredItems = computed(() => {
  if (!searchQuery.value) return props.items
  return props.items.filter(item => 
    item.name.toLowerCase().includes(searchQuery.value.toLowerCase())
  )
})
</script>
```

## Composable Pattern
```typescript
// useApi.ts
export function useApi<T>(url: string) {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const execute = async () => {
    loading.value = true
    error.value = null
    try {
      const response = await fetch(url)
      data.value = await response.json()
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }
  
  return { data: readonly(data), loading: readonly(loading), error: readonly(error), execute }
}
```

## Essential Patterns

### Reactive State
```typescript
// Primitives
const count = ref<number>(0)
const message = ref<string>('')
const isVisible = ref<boolean>(true)

// Objects
const user = reactive<User>({ id: '', name: '', email: '' })

// Arrays
const items = ref<Item[]>([])
```

### Event Handling
```typescript
// Simple events
const handleClick = () => emit('click')

// Events with payload
const handleSelect = (item: Item) => emit('select', item)

// Async events
const handleSave = async () => {
  try {
    await saveData()
    emit('saved')
  } catch (error) {
    emit('error', error)
  }
}
```

### Computed Properties
```typescript
// Simple computed
const fullName = computed(() => `${firstName.value} ${lastName.value}`)

// Computed with complex logic
const filteredAndSorted = computed(() => 
  items.value
    .filter(item => item.active)
    .sort((a, b) => a.name.localeCompare(b.name))
)
```

### Watchers
```typescript
// Watch single value
watch(searchQuery, (newQuery) => {
  if (newQuery) fetchResults(newQuery)
})

// Watch multiple values
watch([prop1, prop2], ([newProp1, newProp2]) => {
  updateSomething(newProp1, newProp2)
})

// Watch with options
watch(deepObject, (newVal) => {
  saveToStorage(newVal)
}, { deep: true, immediate: true })
```