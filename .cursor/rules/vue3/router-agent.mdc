---
title: Vue Router 4 Patterns
tags: [router, navigation]
globs: ["src/router/**/*.ts","src/**/*.vue"]
---

# Vue Router Agent

## Overview
Comprehensive Vue Router 4 patterns for modern Vue 3 applications with TypeScript support.

## Core Principles
- Always use Composition API with `<script setup>`
- Implement type-safe routing with TypeScript
- Use lazy loading for optimal performance
- Apply route guards for security and UX
- Follow RESTful URL patterns

## Route Structure Patterns

### Basic Router Setup
```typescript
// router/index.ts
import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'home',
    component: () => import('@/views/HomeView.vue'),
    meta: { requiresAuth: false, title: 'Home' }
  },
  {
    path: '/dashboard',
    name: 'dashboard',
    component: () => import('@/views/DashboardView.vue'),
    meta: { requiresAuth: true, title: 'Dashboard' },
    children: [
      {
        path: 'profile',
        name: 'profile',
        component: () => import('@/views/ProfileView.vue')
      }
    ]
  },
  {
    path: '/users/:id(\\d+)',
    name: 'user-detail',
    component: () => import('@/views/UserDetailView.vue'),
    props: true
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () => import('@/views/NotFoundView.vue')
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) return savedPosition
    if (to.hash) return { el: to.hash }
    return { top: 0 }
  }
})

// Global navigation guards
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // Set page title
  document.title = to.meta.title ? `${to.meta.title} - App` : 'App'
  
  // Check authentication
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next({ name: 'login', query: { redirect: to.fullPath } })
  } else {
    next()
  }
})

export default router
```

### Component Navigation Patterns

#### Programmatic Navigation
```vue
<script setup lang="ts">
import { useRouter, useRoute } from 'vue-router'

const router = useRouter()
const route = useRoute()

// Type-safe navigation
interface UserParams {
  id: string
}

const navigateToUser = (userId: number) => {
  router.push({ 
    name: 'user-detail', 
    params: { id: userId.toString() } 
  })
}

// Navigation with query parameters
const searchUsers = (query: string) => {
  router.push({ 
    name: 'users', 
    query: { search: query, page: '1' } 
  })
}

// Navigate with state replacement
const replaceRoute = () => {
  router.replace({ name: 'dashboard' })
}

// Go back/forward
const goBack = () => router.go(-1)
</script>
```

#### Route Parameters & Query Handling
```vue
<script setup lang="ts">
import { computed } from 'vue'
import { useRoute, useRouter } from 'vue-router'

const route = useRoute()
const router = useRouter()

// Reactive route parameters
const userId = computed(() => route.params.id as string)
const searchQuery = computed(() => route.query.search as string || '')
const currentPage = computed(() => Number(route.query.page) || 1)

// Update query parameters
const updateSearch = (query: string) => {
  router.push({
    query: { 
      ...route.query, 
      search: query,
      page: '1' // Reset to first page
    }
  })
}

// Watch for route changes
watch(
  () => route.params.id,
  (newId) => {
    if (newId) {
      // Fetch user data when ID changes
      fetchUserData(newId)
    }
  },
  { immediate: true }
)
</script>
```

### Route Guards Patterns

#### Per-Route Guards
```typescript
// In route definition
{
  path: '/admin',
  component: () => import('@/views/AdminView.vue'),
  beforeEnter: (to, from, next) => {
    const authStore = useAuthStore()
    if (authStore.user?.role === 'admin') {
      next()
    } else {
      next({ name: 'unauthorized' })
    }
  }
}
```

#### Component Guards
```vue
<script setup lang="ts">
import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'
import { ref } from 'vue'

const hasUnsavedChanges = ref(false)

// Prevent navigation if there are unsaved changes
onBeforeRouteLeave((to, from, next) => {
  if (hasUnsavedChanges.value) {
    const answer = window.confirm(
      'You have unsaved changes. Are you sure you want to leave?'
    )
    if (answer) {
      next()
    } else {
      next(false)
    }
  } else {
    next()
  }
})

// Handle route updates (same component, different params)
onBeforeRouteUpdate(async (to, from, next) => {
  // Fetch new data based on route params
  await fetchData(to.params.id)
  next()
})
</script>
```

## TypeScript Integration

### Route Meta Types
```typescript
// types/router.d.ts
import 'vue-router'

declare module 'vue-router' {
  interface RouteMeta {
    requiresAuth?: boolean
    title?: string
    roles?: string[]
    layout?: 'default' | 'admin' | 'auth'
  }
}
```

### Typed Route Names
```typescript
// composables/useTypedRouter.ts
import { useRouter, type RouteLocationRaw } from 'vue-router'

type RouteNames = 'home' | 'dashboard' | 'user-detail' | 'profile'

export const useTypedRouter = () => {
  const router = useRouter()
  
  const pushTo = (name: RouteNames, params?: Record<string, string>) => {
    router.push({ name, params })
  }
  
  return { pushTo }
}
```

## Best Practices

1. **Lazy Loading**: Always use dynamic imports for route components
2. **Route Naming**: Use kebab-case for route names
3. **Parameter Validation**: Use regex patterns for route parameters
4. **Meta Fields**: Use route meta for permissions and page titles
5. **Error Handling**: Always include 404 and error routes
6. **Query Parameters**: Use computed properties for reactive query handling
7. **Navigation Guards**: Implement proper loading states during route changes